---
title: MySQL存储过程
date: 2020-11-21
categories:
  - MySQL
tags:
  - MySQL
---

一组为了完成特定功能的 SQL 语句集，存储在数据库中，经过第一次编译后再次调用不需要再次编译，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。存储过程是数据库中的一个重要对象。

MySQL 存储过程是从 MySQL5.0 开始增加的新功能。存储过程的优点有一箩筐。不过最主要的还是执行效率和 SQL 代码封装。特别是 SQL 代码封装功能，如果没有存储过程，在外部程序访问数据库时，要组织很多 SQL 语句。特别是业务逻辑复杂的时候，一大堆的 SQL 和条件夹杂在代码中，让人不寒而栗。现在有了 MySQL 存储过程，业务逻辑可以封装存储过程中，这样不仅容易维护，而且执行效率也高。

一、创建 MySQL 存储过程
下面代码创建了一个叫 pr_add 的 MySQL 存储过程，这个 MySQL 存储过程有两个 int 类型的输入参数“a”、“b”，返回这两个参数的和。
1） drop procedure if exists pr_add; （备注：如果存在 pr_add 的存储过程，则先删掉）
2） 计算两个数之和（备注：实现计算两个整数之和的功能）

```sql
create procedure pr_add	(	a int,	b int	)	begin	declare c int;
if a is null then	set a = 0;
end if;
if b is null then	set b = 0;
end if;
set c = a + b;
select c as sum;

```

二、调用 MySQL 存储过程
call pr_add(10, 20);

### 存储过程优化思路：

1. 尽量利用一些 sql 语句来替代一些小循环，例如聚合函数，求平均函数等。

2. 中间结果存放于临时表，加索引。

3. 少使用游标。sql 是个集合语言，对于集合运算具有较高性能。而 cursors 是过程运算。比如对一个 100 万行的数据进行查询。游标需要读表 100 万次，而不使用游标则只需要少量几次读取。

4. 事务越短越好。sqlserver 支持并发操作。如果事务过多过长，或者隔离级别过高，都会造成并发操作的阻塞，死锁。导致查询极慢，cpu 占用率极地。

5. 使用 try-catch 处理错误异常。

6. 查找语句尽量不要放在循环内。

### 触发器

触发器是一段能自动执行的程序，是一种特殊的存储过程，触发器和普通的存储过程的区别是： 触发器是当对某一个表进行操作时触发。诸如：update、insert、delete 这些操作的时候，系统会自动调用执行该表上对应的触发器。SQL Server 2005 中触发器可以分为两类：`DML 触发器`和`DDL 触发器`，其中 DDL 触发器它们会影响多种数据定义语言语句而激发，这些语句有 create、alter、drop 语句。

MySQL 包含对触发器的支持。触发器是一种与表操作有关的数据库对象，当触发器所在表上出现指定事件时，将调用该对象，即表的操作事件触发表上的触发器的执行。
在 MySQL 中，创建触发器语法如下：

其中：
`trigger_name`： 标 识 触 发 器 名 称 ， 用 户 自 行 指 定 ； `trigger_time`：标识触发时机，取值为 BEFORE 或 AFTER；
`trigger_event`：标识触发事件，取值为 INSERT、UPDATE 或 DELETE；

`tbl_name`：标识建立触发器的表名，即在哪张表上建立触发器；
`trigger_stmt`：触发器程序体，可以是一句 SQL 语句，或者用 BEGIN 和 END 包含的多条语句。
由此可见，可以建立 6 种触发器，即：`BEFORE INSERT`、`BEFORE UPDATE`、`BEFORE DELETE`、`AFTER INSERT`、`AFTER UPDATE`、`AFTER DELETE`。
另外有一个限制是不能同时在一个表上建立 2 个相同类型的触发器，因此在一个表上最多建立 6 个触发器。假设系统中有两个表：
372

1. 班级表 class(班级号 classID, 班内学生数 stuCount) 2)学生表 student(学号 stuID, 所属班级号 classID)
   要创建触发器来使班级表中的班内学生数随着学生的添加自动更新，代码如下：

查看触发器：
和查看数据库（show databases;）查看表格（show tables;）一样，查看触发器的语法如下：
SHOW TRIGGERS [FROM schema_name];
其中，schema_name 即 Schema 的名称，在 MySQL 中 Schema 和 Database 是一样的，也就是说，可以指定数据库名，这样就不必先“USE database_name;”了。
删除触发器：
和删除数据库、删除表格一样，删除触发器的语法如下：
DROP TRIGGER [IF EXISTS][schema_name.]trigger_name

## 数据库并发策略

并发控制一般采用三种方法，分别是乐观锁和悲观锁以及时间戳。

### 乐观锁

乐观锁认为一个用户读数据的时候，别人不会去写自己所读的数据；悲观锁就刚好相反，觉得自己读数据库的时候，别人可能刚好在写自己刚读的数据，其实就是持一种比较保守的态度；时间戳就是不加锁，通过时间戳来控制并发出现的问题。

### 悲观锁

悲观锁就是在读取数据的时候，为了不让别人修改自己读取的数据，就会先对自己读取的数据加锁，只有自己把数据读完了，才允许别人修改那部分数据，或者反过来说，就是自己修改某条数据的时候，不允许别人读取该数据，只有等自己的整个事务提交了，才释放自己加上的锁，才允许其他用户访问那部分数据。

### 时间戳

时间戳就是在数据库表中单独加一列时间戳，比如“TimeStamp”，每次读出来的时候，把该字段也读出来，当写回去的时候，把该字段加 1，提交之前，跟数据库的该字段比较一次，如果比数据库的值大的话，就允许保存，否则不允许保存，这种处理方法虽然不使用数据库系统提供的锁机制，但是这种方法可以大大提高数据库处理的并发量，

以上悲观锁所说的加“锁”，其实分为几种锁，分别是：排它锁（写锁）和共享锁（读锁）。

## 数据库锁

### 行级锁

行级锁是一种排他锁，防止其他事务修改此行；在使用以下语句时，Oracle 会自动应用行级锁：

1. INSERT、UPDATE、DELETE、SELECT … FOR UPDATE OF columns;

2. SELECT … FOR UPDATE 语句允许用户一次锁定多条记录进行更新

3. 使用 COMMIT 或 ROLLBACK 语句释放锁。

### 表级锁

表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分 MySQL 引擎支持。最常使用的 MYISAM 与 INNODB 都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁

（排他锁）。

### 页级锁

页级锁是 MySQL 中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。BDB 支持页级锁

## Mysql 存储引擎有哪些？

- InnoDB 存储引擎

InnoDB 是事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键，InnoDB 是默认的 MySQL

引擎。

- MyISAM 存储引擎

MyISAM 基于 ISAM 存储引擎，并对其进行扩展。它是在 Web、数据仓储和其他应用环境下最常使用的存储引擎之一。MyISAM 拥有较高的插入、查询速度，但不支持事物。

- MEMORY 存储引擎

MEMORY 存储引擎将表中的数据存储到内存中，未查询和引用其他表数据提供快速访问。

- NDB 存储引擎

DB 存储引擎是一个集群存储引擎，类似于 Oracle 的 RAC，但它是 Share Nothing 的架构，因此能提供更高级别的高可用性和可扩展性。NDB 的特点是数据全部放在内存中，因此通过主键查找非常快。

关于 NDB，有一个问题需要注意，它的连接( join)操作是在 MySQL 数据库层完成，不是在存储引擎层完成，这意味着，复杂的 join 操作需要巨大的网络开销，查询速度会很慢。

- Memory (Heap) 存储引擎

Memory 存储引擎（之前称为 Heap）将表中数据存放在内存中，如果数据库重启或崩溃，数据丢失，因此它非常适合存储临时数据。

- Archive 存储引擎

正如其名称所示，Archive 非常适合存储归档数据，如日志信息。它只支持 INSERT 和 SELECT 操作，其设计的主要目的是提供高速的插入和压缩功能。

- Federated 存储引擎

Federated 存储引擎不存放数据，它至少指向一台远程 MySQL 数据库服务器上的表，非常类似于 Oracle 的透明网关。

- Maria 存储引擎

Maria 存储引擎是新开发的引擎，其设计目标是用来取代原有的 MyISAM 存储引擎，从而成为 MySQL 默认的存储引擎。

上述引擎中，InnoDB 是事务安全的存储引擎，设计上借鉴了很多 Oracle 的架构思想，一般而言，在 OLTP 应用中，InnoDB 应该作为核心应用表的首先存储引擎。InnoDB 是由第三方的 Innobase Oy 公司开发，现已被 Oracle 收购，创始人是 Heikki Tuuri，芬兰赫尔辛基人，和著名的 Linux 创始人 Linus 是校友。
